
  项目分层结构

  inkrhyme-audio-backend/
  ├── model/                    # 实体类、VO、DTO 等数据模型
  ├── common/                   # 公共工具模块
  │   ├── common-util/         # 通用工具类
  │   ├── common-log/          # 日志模块
  │   ├── service-util/        # 服务层通用工具
  │   └── rabbit-util/         # RabbitMQ 工具
  ├── service-client/          # Feign 客户端接口定义（重点）
  │   ├── service-album-client/
  │   ├── service-search-client/
  │   ├── service-user-client/
  │   └── ...
  ├── service/                 # 微服务实现
  │   ├── service-album/       # 专辑服务
  │   ├── service-search/      # 搜索服务
  │   ├── service-user/        # 用户服务
  │   └── ...
  └── server-gateway/          # 网关

  service-client 的作用

  service-client 不是对外提供服务的，而是用于微服务之间内部调用的 Feign 客户端接口定义。

  看这个例子（SearchFeignClient.java:19）：

  @FeignClient(value = "service-search", fallback = SearchDegradeFeignClient.class)                                                                 
  public interface SearchFeignClient {
      @GetMapping("api/search/albumInfo/updateLatelyAlbumRanking")                                                                                  
      Result updateLatelyAlbumRanking();
  }

  它定义了调用 service-search 服务的接口契约。

  调用链路示例

  从 DispatchJobHandler.java:40 可以看到调用过程：

  service-dispatch (调用方)
      ↓ 注入 SearchFeignClient
      ↓ searchFeignClient.updateLatelyAlbumRanking()
      ↓ 通过 Feign 远程调用
  service-search (提供方)
      ↓ 实际执行业务逻辑

  依赖关系

  查看 service/pom.xml:40-67，所有 service 模块都依赖了所有的 service-client：

  <dependencies>                                                                                                                                  
      <dependency>service-system-client</dependency>                                                                                                
      <dependency>service-account-client</dependency>                                                                                               
      <dependency>service-album-client</dependency>                                                                                                 
      <!-- ... 所有 client -->                                                                                                                     
  </dependencies>                                                                                                                                   

  这个架构的特点（也是问题所在）

  1. 所有服务都依赖所有客户端 - 这导致了强耦合，任何一个服务都可以调用其他所有服务
  2. client 模块只定义接口 - 不包含实现，实现在对应的 service 中
  3. 通过 Feign 进行服务间调用 - 基于 Spring Cloud 的微服务通信

  通常更好的做法是：
  - 每个服务只依赖它真正需要调用的 client
  - 避免循环依赖和过度耦合
  - 考虑使用事件驱动（消息队列）减少直接调用

  这个项目是个人项目，为了简化配置采用了"all-in"的依赖方式，但在生产环境中建议按需依赖。



